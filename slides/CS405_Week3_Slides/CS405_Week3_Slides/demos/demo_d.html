<!DOCTYPE html>
<html><head><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta charset="utf-8"><title>Demo D — Normal Matrix</title>
<style>
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:#fff;color:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
.page{max-width:100%;margin:0 auto;min-height:100vh;border:2px solid #000;display:flex;flex-direction:column}
.header{padding:12px 16px;border-bottom:2px solid #000}
.title{font-size:32px;font-weight:800}
.content{padding:16px;display:flex;flex-direction:column;gap:12px}
.controls label{display:inline-block;min-width:100%}
.controls input,.controls select{font-size:18px}
canvas{width:100%;height:min(70vh, 820px);min-height:auto;border:2px solid #000;background:#fff;display:block}
#log{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;border:1px dashed #000;padding:8px;background:#fafafa}
a.nav{display:inline-block;margin:12px 16px 16px 16px;border:2px solid #000;padding:8px 12px;color:#000;text-decoration:none;font-weight:700;align-self:flex-start;background:#fff}

:root{
  --maxw: 1200px;
  --pad: clamp(12px, 2.2vw, 24px);
  --fs-body: clamp(16px, 2.0vw, 28px);
  --fs-title: clamp(22px, 3.2vw, 40px);
  --fs-caption: clamp(14px, 1.6vw, 22px);
}
html, body { height:100%; margin:0; background:#fff; color:#000; }
.page{
  max-width: var(--maxw);
  width: min(100%, var(--maxw));
  margin: 0 auto;
  min-height: 100svh;
  border: 2px solid #000;
  display: flex;
  flex-direction: column;
}
.header{ padding: var(--pad); border-bottom:2px solid #000; }
.title{ font-size: var(--fs-title); font-weight: 800; }
.content{
  padding: var(--pad);
  display:flex; flex-direction:column; gap: clamp(10px,1.5vw,20px);
  font-size: var(--fs-body); line-height:1.5;
}
.slide-img{
  display:block; max-width:100%; height:auto;
  margin: clamp(8px,1.2vw,16px) auto; border:2px solid #000;
}
.figure{ margin:0; }
.caption{ font-size: var(--fs-caption); text-align:center; margin:8px auto 12px; }
.caption span{ display:inline-block; padding:2px 6px; border:1px solid #000; background:#f7f7f7; }
pre{
  background:#f5f5f5; border:1px solid #000;
  padding: clamp(8px,1.5vw,16px);
  white-space: pre-wrap; overflow:auto;
  font-size: clamp(14px,1.8vw,22px);
}
code{ font-size: clamp(14px,1.8vw,22px); }
.nav-prev, .nav-next{
  position: fixed; bottom: clamp(10px, 2vh, 20px);
  padding: clamp(8px,1vw,12px) clamp(10px,1.2vw,14px);
  border:2px solid #000; background:#fff; color:#000; text-decoration:none; font-weight:700; z-index:10;
}
.nav-prev{ left: clamp(10px, 2vw, 24px); }
.nav-next{ right: clamp(10px, 2vw, 24px); }
.footer-spacer{ height: clamp(48px, 8vh, 80px); }
@media (max-width:100%){ .header,.content{ padding:12px; } }


.nav-center{
  position: fixed; bottom: clamp(10px, 2vh, 20px);
  left: 50%; transform: translateX(-50%);
  padding: clamp(8px,1vw,12px) clamp(12px,1.6vw,16px);
  border: 2px solid #000; background:#fff; color:#000;
  font-weight:700; z-index:10; white-space:nowrap;
}
.nav-center a{ color:#000; text-decoration:none; }
.nav-center a + a{ margin-left: 12px; }

</style></head>
<body>
<div class="page">
  <div class="header"><div class="title">Demo D — Normal Matrix (Lighting)</div></div>
  <div class="content">
    <div class="controls">
      <label>Sx</label><input id="nsx" type="range" min="0.3" max="3.0" step="0.01" value="1">
      <label>Sy</label><input id="nsy" type="range" min="0.3" max="3.0" step="0.01" value="1">
      <label>Sz</label><input id="nsz" type="range" min="0.3" max="3.0" step="0.01" value="1">
      <label>Correct</label><input id="useNM" type="checkbox" checked>
    </div>
    <canvas id="gl"></canvas>
    <pre id="log"></pre>
  </div>
  <a class="nav" href="index.html">Back</a>
</div>
<script>
// Column-major 4x4 matrices (OpenGL/WebGL): m[col*4 + row]
const Mat4 = {
  identity: () => [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1],
  multiply: (a,b) => {
    const out = new Array(16);
    for (let c=0;c<4;c++) for (let r=0;r<4;r++)
      out[c*4+r] = a[0*4+r]*b[c*4+0] + a[1*4+r]*b[c*4+1] + a[2*4+r]*b[c*4+2] + a[3*4+r]*b[c*4+3];
    return out;
  },
  translate: (m,[x,y,z]) => Mat4.multiply(m,[1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]),
  scale: (m,[x,y,z]) => Mat4.multiply(m,[x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]),
  rotateX: (m,a) => { const c=Math.cos(a),s=Math.sin(a); return Mat4.multiply(m,[1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); },
  rotateY: (m,a) => { const c=Math.cos(a),s=Math.sin(a); return Mat4.multiply(m,[c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); },
  rotateZ: (m,a) => { const c=Math.cos(a),s=Math.sin(a); return Mat4.multiply(m,[c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1]); },
  perspective: (fovy, aspect, near, far) => {
    const f = 1/Math.tan(fovy/2), nf = 1/(near - far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0];
  },
  lookAt: (eye,center,up) => {
    let [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
    let zx=ex-cx, zy=ey-cy, zz=ez-cz; const zlen=Math.hypot(zx,zy,zz); zx/=zlen; zy/=zlen; zz/=zlen;
    let xx=uy*zz-uz*zy, xy=uz*zx-ux*zz, xz=ux*zy-uy*zx; const xlen=Math.hypot(xx,xy,xz); xx/=xlen; xy/=xlen; xz/=xlen;
    let yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx;
    return [xx,yx,zx,0,  xy,yy,zy,0,  xz,yz,zz,0,  -(xx*ex+xy*ey+xz*ez), -(yx*ex+yy*ey+yz*ez), -(zx*ex+zy*ey+zz*ez), 1];
  }
};
function resizeCanvasToDisplaySize(canvas){
  const dpr = window.devicePixelRatio || 1;
  const w = Math.max(1, Math.floor(canvas.clientWidth * dpr));
  const h = Math.max(1, Math.floor(canvas.clientHeight * dpr));
  if (canvas.width !== w || canvas.height !== h) { canvas.width=w; canvas.height=h; }
}
function glerr(gl, label){
  const e = gl.getError(); if (e!==gl.NO_ERROR) console.warn(label, e);
}
</script>
<script>
(function(){
  const log = document.getElementById('log');
  const canvas=document.getElementById('gl'); const gl=canvas.getContext('webgl'); if(!gl){ log.textContent='WebGL not supported'; return; }
  function comp(t,src){ const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  function prog(vs,fs){ const p=gl.createProgram(); gl.attachShader(p,comp(gl.VERTEX_SHADER,vs)); gl.attachShader(p,comp(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
  const VS='attribute vec3 aPosition; attribute vec3 aNormal; uniform mat4 uMVP; uniform mat4 uModel; uniform mat3 uNormalMatrix; uniform bool uUseNM; varying vec3 vN; void main(){ vec3 N=aNormal; if(uUseNM) N=normalize(uNormalMatrix*aNormal); vN=N; gl_Position=uMVP*vec4(aPosition,1.0);}';
  const FS='precision mediump float; varying vec3 vN; void main(){ vec3 L=normalize(vec3(0.6,0.7,0.5)); float NdotL=max(dot(normalize(vN),L),0.0); gl_FragColor=vec4(vec3(0.15+0.85*NdotL),1.0);}';
  let p; try{ p=prog(VS,FS);} catch(e){ log.textContent=e.toString(); return;}
  gl.useProgram(p);
  const lat=24, lon=24, R=1.0; const verts=[], norms=[], idx=[];
  for(let i=0;i<=lat;i++){ const th=i*Math.PI/lat; for(let j=0;j<=lon;j++){ const ph=j*2*Math.PI/lon; const x=Math.sin(th)*Math.cos(ph), y=Math.cos(th), z=Math.sin(th)*Math.sin(ph); verts.push(R*x,R*y,R*z); norms.push(x,y,z); } }
  for(let i=0;i<lat;i++){ for(let j=0;j<lon;j++){ const a=i*(lon+1)+j; const b=a+lon+1; idx.push(a,b,a+1, b,b+1,a+1); } }
  const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(verts),gl.STATIC_DRAW);
  const nbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,nbo); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(norms),gl.STATIC_DRAW);
  const ibo=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(idx),gl.STATIC_DRAW);
  const aP=gl.getAttribLocation(p,'aPosition'); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.enableVertexAttribArray(aP); gl.vertexAttribPointer(aP,3,gl.FLOAT,false,0,0);
  const aN=gl.getAttribLocation(p,'aNormal'); gl.bindBuffer(gl.ARRAY_BUFFER,nbo); gl.enableVertexAttribArray(aN); gl.vertexAttribPointer(aN,3,gl.FLOAT,false,0,0);
  const uMVP=gl.getUniformLocation(p,'uMVP'), uModel=gl.getUniformLocation(p,'uModel'), uNM=gl.getUniformLocation(p,'uNormalMatrix'), uUseNM=gl.getUniformLocation(p,'uUseNM');
  gl.enable(gl.DEPTH_TEST); gl.clearColor(1,1,1,1);
  function invTrans3x3(m){ const a=m[0], b=m[1], c=m[2], d=m[4], e=m[5], f=m[6], g=m[8], h=m[9], i=m[10];
    const A=e*i-f*h, B=-(d*i-f*g), C=d*h-e*g, D=-(b*i-c*h), E=a*i-c*g, F=-(a*h-b*g), G=b*f-c*e, H=-(a*f-c*d), I=a*e-b*d;
    const det=a*A+b*B+c*C; const inv=[A/det,D/det,G/det, B/det,E/det,H/det, C/det,F/det,I/det]; return [inv[0],inv[3],inv[6], inv[1],inv[4],inv[7], inv[2],inv[5],inv[8]]; }
  function render(){
    resizeCanvasToDisplaySize(canvas);
    const sx=+document.getElementById('nsx').value, sy=+document.getElementById('nsy').value, sz=+document.getElementById('nsz').value;
    const useNM=document.getElementById('useNM').checked;
    let M=Mat4.identity(); M=Mat4.rotateY(M,0.8); M=Mat4.scale(M,[sx,sy,sz]);
    const V=Mat4.lookAt([0,0,4],[0,0,0],[0,1,0]);
    const P=Mat4.perspective(60*Math.PI/180, canvas.width/canvas.height, 0.1, 100);
    const MVP=Mat4.multiply(Mat4.multiply(P,V),M);
    const NM=invTrans3x3(M);
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.uniformMatrix4fv(uMVP,false,new Float32Array(MVP));
    gl.uniformMatrix4fv(uModel,false,new Float32Array(M));
    gl.uniformMatrix3fv(uNM,false,new Float32Array(NM));
    gl.uniform1i(uUseNM, useNM?1:0);
    gl.drawElements(gl.TRIANGLES, idx.length, gl.UNSIGNED_SHORT, 0);
  }
  ['nsx','nsy','nsz','useNM'].forEach(id=>document.getElementById(id).addEventListener('input',render));
  window.addEventListener('resize', render);
  render();
})();
</script>
<div class="nav-center"><a href="index.html">Home</a> · <a href="demos/index.html">Demos</a></div>
</body></html>
