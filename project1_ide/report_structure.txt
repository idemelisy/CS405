CS405 Project 1 Report Structure
1. Introduction & Overview
• Project Scope: 3D WebGL application demonstrating transformations, camera systems, projections, and Bézier curves
• Technology Stack: Pure JavaScript + WebGL (no external libraries), column-major matrix convention
• Architecture: Modular design with separate files for math operations, camera, Bézier curves, rendering, and application logic
• Learning Objectives: Understanding complete transformation pipeline: p_clip = P × V × M × p_object

2. Part A - Rigid Body Transformations
Mathematics Behind Transformations:
• 4×4 Homogeneous Matrices: Used for affine transformations in 3D space
• Translation Matrix T: T = [1 0 0 tx; 0 1 0 ty; 0 0 1 tz; 0 0 0 1] (column-major)
• Scaling Matrix S: S = [sx 0 0 0; 0 sy 0 0; 0 0 sz 0; 0 0 0 1]
• Rotation Matrices:

X-axis: Rx = [1 0 0 0; 0 cos(θ) sin(θ) 0; 0 -sin(θ) cos(θ) 0; 0 0 0 1]
Y-axis: Ry = [cos(θ) 0 -sin(θ) 0; 0 1 0 0; sin(θ) 0 cos(θ) 0; 0 0 0 1]
Z-axis: Rz = [cos(θ) sin(θ) 0 0; -sin(θ) cos(θ) 0 0; 0 0 1 0; 0 0 0 1]
Implementation Details:
• Matrix Order: Column-major storage for WebGL compatibility
• Transformation Composition: Six different orders (TRS, TSR, RTS, RST, STR, SRT)
• Matrix Multiplication: Custom implementation for 4×4 matrices using nested loops
• Interactive Controls: Real-time sliders for translation (-5 to +5), rotation (-180° to +180°), scaling (0.1 to 3.0)

Experimental Validation:
• Order Dependency Test: Demonstrate how TRS ≠ RTS by applying same transformations in different orders
• Matrix Verification: Export transformation matrices in JSON format for mathematical validation
• Visual Confirmation: Colored cube (6 faces with distinct colors) shows transformation effects clearly

3. Part B - Camera System & View Matrix
Mathematical Foundation:
• LookAt Matrix Construction: V = lookAt(eye, target, up)
• Camera Coordinate System:

Forward vector: f = normalize(eye - target)
Right vector: r = normalize(up × f)
Up vector: u = f × r
• View Matrix Formula: V = [r.x u.x f.x 0; r.y u.y f.y 0; r.z u.z f.z 0; -dot(r,eye) -dot(u,eye) -dot(f,eye) 1]
• Orbital Camera Mathematics: Spherical coordinates conversion for camera positioning
Implementation Features:
• Interactive Camera Controls: Mouse drag for rotation, scroll for zoom, range: 2-50 units distance
• Camera Visualization:

Coordinate axes (X=red, Y=green, Z=blue) with 5-unit length
Camera position indicator (magenta cube at actual camera location)
Frustum visualization with wireframe rendering
• Orbital Movement: Constrained rotation (±89° vertical) to prevent gimbal lock
Camera Frustum Visualization:
• Frustum Geometry: Wireframe representation of view volume
• Interactive Parameters: FOV (10°-120°), near plane (0.1-20.0), far plane (2.0-50.0)
• Visual Design: Color-coded wireframe (yellow=near, cyan=far, orange/magenta=boundaries)

4. Part C - Projection Matrices
Perspective Projection Mathematics:
• Projection Matrix: P = [f/aspect 0 0 0; 0 f 0 0; 0 0 (far+near)/(near-far) -1; 0 0 2*far*near/(near-far) 0]
• Field of View: f = 1/tan(fov/2) - controls perspective distortion
• Aspect Ratio: aspect = width/height - prevents stretching
• Clipping Planes: Near and far planes define view volume boundaries

Orthographic Projection Mathematics:
• Orthographic Matrix: P = [2/(r-l) 0 0 0; 0 2/(t-b) 0 0; 0 0 -2/(f-n) 0; -(r+l)/(r-l) -(t+b)/(t-b) -(f+n)/(f-n) 1]
• Parallel Projection: No perspective distortion, maintains object proportions
• View Volume: Rectangular box defined by left, right, top, bottom, near, far

Implementation & Experiments:
• Dynamic Switching: Toggle between perspective and orthographic projection
• Interactive Parameters: Real-time FOV adjustment with immediate visual feedback
• Near/Far Plane Testing: Adjustable clipping planes with frustum visualization
• Validation: Matrix export shows correct projection values for different settings

5. Part D - Bézier Curves
Cubic Bézier Mathematics:
• Parametric Formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
• Bernstein Polynomials: Basis functions ensuring curve interpolation properties
• First Derivative: B'(t) = -3(1-t)²P₀ + 3(1-t)²P₁ - 6(1-t)tP₁ + 6(1-t)tP₂ - 3t²P₂ + 3t²P₃
• Tangent Vectors: Used for object orientation along curve path

Implementation Details:
• 3D Control Points: Four points in world space with interactive manipulation
• Curve Tessellation: 100 segments for smooth rendering with color gradient (blue→red)
• Control Polygon: Gray lines connecting control points for visualization
• Interactive Editing: Mouse-based control point manipulation with screen-to-world coordinate conversion

Animation System:
• Parameter Animation: t ∈ [0,1] with ping-pong motion (forward and reverse)
• Speed Control: Adjustable animation speed (0.001 to 0.02 per frame)
• Object Following: Animated cube moves along curve with tangent-based orientation
• Real-time Updates: Animation parameter display with 3 decimal precision

6. Part E - Integration & Experiments
Complete Transformation Pipeline:
• Matrix Chain: Final Position = Projection × View × Model × Vertex
• Render Loop: 60fps animation with continuous updates
• State Management: Unified application state with modular components

Validation Experiments:

1. Matrix Mathematics Verification:
• Export transformation matrices in JSON format
• Verify matrix multiplication results match mathematical expectations
• Test identity matrix properties and transformation composition

2. Projection Comparison:
• Side-by-side comparison of perspective vs orthographic projection
• Document how FOV changes affect perspective distortion
• Test near/far plane clipping with objects at different depths

3. Camera System Testing:
• Verify lookAt matrix produces correct view transformations
• Test orbital camera constraints and smooth interpolation
• Validate frustum visualization matches actual projection parameters

4. Bézier Curve Validation:
• Verify curve passes through P₀ and P₃ (endpoints)
• Test curve lies within convex hull of control points
• Validate tangent vectors at endpoints match control polygon direction

5. Interactive Performance:
• Real-time parameter updates without frame rate drops
• Smooth mouse interaction for camera and control point manipulation
• Responsive UI with immediate visual feedback

7. Technical Implementation
WebGL Rendering Pipeline:
• Vertex Shader: Applies complete transformation chain with matrix uniforms
• Fragment Shader: Handles color interpolation and alpha blending
• Buffer Management: Dynamic geometry updates for interactive elements
• Depth Testing: Z-buffer for correct 3D rendering

User Interface:
• Responsive Design: Grid layout with canvas and control panel
• Real-time Feedback: Slider values update immediately with visual changes
• Matrix Export: JSON formatted output for mathematical verification
• Camera Information: Live display of camera position, target, and distance

8. Results & Analysis
Mathematical Accuracy:
• All transformation matrices produce mathematically correct results
• Projection matrices handle perspective divide and clipping correctly
• Bézier curves follow exact cubic polynomial evaluation

Visual Quality:
• Smooth animations at 60fps with proper depth testing
• Clear frustum visualization aids in understanding camera parameters
• Color-coded elements enhance learning (axes, control points, frustum)

Educational Value:
• Interactive parameter adjustment demonstrates mathematical concepts
• Matrix export enables verification of computational results
• Complete transformation pipeline visible from model to screen space

This structure provides comprehensive coverage of your implementation with mathematical foundations, technical details, and experimental validation for each major component.