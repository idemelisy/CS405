<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Transformations - CS405</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 10px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        h2 {
            color: #667eea;
            margin: 30px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }
        
        h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
        }
        
        .section {
            background: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .demo-container {
            background: #fafafa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        canvas {
            display: block;
            border: 2px solid #667eea;
            background: #fff;
            border-radius: 5px;
            width: 100%;
            max-width: 800px;
            height: 600px;
            margin: 0 auto;
        }
        
        .controls {
            margin: 15px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button.active {
            background: #764ba2;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        label {
            font-weight: 600;
            font-size: 14px;
            color: #555;
        }
        
        .math-display {
            background: #f8f9fa;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .code-box {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .matrix-display {
            background: #f0f0f0;
            border: 2px solid #667eea;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        
        .matrix-display table {
            margin: 10px auto;
            border-collapse: collapse;
        }
        
        .matrix-display td {
            padding: 8px 12px;
            text-align: right;
            border: 1px solid #999;
            background: white;
            min-width: 80px;
        }
        
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .slider-value {
            font-weight: 600;
            color: #667eea;
            font-size: 16px;
            text-align: center;
        }
        
        .instruction-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background: #667eea;
            color: white;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .order-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .order-buttons button {
            flex: 1;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <header>
        <h1>WebGL Transformations</h1>
        <p>Understanding Matrix Mathematics, Memory Layout, and Transformation Order</p>
    </header>

    <div class="container">
        <!-- Introduction -->
        <div class="section">
            <h2>1. Introduction to Transformations</h2>
            <p>Transformations are the foundation of 3D graphics. They allow us to:</p>
            <ul>
                <li>Position objects in 3D space (Translation)</li>
                <li>Change their orientation (Rotation)</li>
                <li>Adjust their size (Scaling)</li>
                <li>Create complex hierarchical models</li>
            </ul>
            
            <div class="info-box">
                <strong>Key Concept:</strong> In WebGL, we use 4×4 matrices to represent transformations. 
                These matrices work with homogeneous coordinates (x, y, z, w) where w=1 for points and w=0 for vectors.
            </div>
        </div>

        <!-- Matrix Representation -->
        <div class="section">
            <h2>2. Matrix Representation: Column-Major vs Row-Major</h2>
            
            <h3>Understanding Memory Layout</h3>
            <p>One of the most confusing aspects of WebGL is the difference between mathematical notation and memory storage.</p>
            
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>Column-Major (WebGL/OpenGL)</h4>
                    <p>Matrices are stored column-by-column in memory:</p>
                    <div class="math-display">
                        \[M = \begin{bmatrix}
                        m_0 & m_4 & m_8 & m_{12} \\
                        m_1 & m_5 & m_9 & m_{13} \\
                        m_2 & m_6 & m_{10} & m_{14} \\
                        m_3 & m_7 & m_{11} & m_{15}
                        \end{bmatrix}\]
                    </div>
                    <p><strong>Memory:</strong> [m₀, m₁, m₂, m₃, m₄, m₅, ...]</p>
                </div>
                
                <div class="comparison-item">
                    <h4>Row-Major (DirectX/Math Notation)</h4>
                    <p>Matrices are stored row-by-row in memory:</p>
                    <div class="math-display">
                        \[M = \begin{bmatrix}
                        m_0 & m_1 & m_2 & m_3 \\
                        m_4 & m_5 & m_6 & m_7 \\
                        m_8 & m_9 & m_{10} & m_{11} \\
                        m_{12} & m_{13} & m_{14} & m_{15}
                        \end{bmatrix}\]
                    </div>
                    <p><strong>Memory:</strong> [m₀, m₁, m₂, m₃, m₄, m₅, ...]</p>
                </div>
            </div>

            <div class="warning-box">
                <strong>Critical for WebGL:</strong> WebGL uses <strong>column-major</strong> ordering. 
                When you create a matrix in JavaScript as a flat array, the first 4 elements are the 
                <strong>first column</strong>, not the first row!
            </div>

            <h3>Translation Matrix in WebGL</h3>
            <div class="math-display">
                <p>Mathematical notation (what you see in textbooks):</p>
                \[T = \begin{bmatrix}
                1 & 0 & 0 & t_x \\
                0 & 1 & 0 & t_y \\
                0 & 0 & 1 & t_z \\
                0 & 0 & 0 & 1
                \end{bmatrix}\]
                
                <p>WebGL memory layout (column-major):</p>
                <code>[ 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  tx, ty, tz, 1 ]</code>
            </div>

            <div class="code-box">
// Creating a translation matrix in WebGL (column-major)
function createTranslation(tx, ty, tz) {
    return [
        1, 0, 0, 0,    // First column
        0, 1, 0, 0,    // Second column
        0, 0, 1, 0,    // Third column
        tx, ty, tz, 1  // Fourth column (translation)
    ];
}

// Vector multiplication: result = Matrix × Vector
// With column-major: P' = M * P
// The matrix multiplies from the LEFT
            </div>
        </div>

        <!-- Basic Transformations -->
        <div class="section">
            <h2>3. Basic Transformation Matrices</h2>
            
            <h3>Translation</h3>
            <div class="math-display">
                \[T(t_x, t_y, t_z) = \begin{bmatrix}
                1 & 0 & 0 & t_x \\
                0 & 1 & 0 & t_y \\
                0 & 0 & 1 & t_z \\
                0 & 0 & 0 & 1
                \end{bmatrix}\]
            </div>

            <h3>Scaling</h3>
            <div class="math-display">
                \[S(s_x, s_y, s_z) = \begin{bmatrix}
                s_x & 0 & 0 & 0 \\
                0 & s_y & 0 & 0 \\
                0 & 0 & s_z & 0 \\
                0 & 0 & 0 & 1
                \end{bmatrix}\]
            </div>

            <h3>Rotation around Z-axis</h3>
            <div class="math-display">
                \[R_z(\theta) = \begin{bmatrix}
                \cos\theta & -\sin\theta & 0 & 0 \\
                \sin\theta & \cos\theta & 0 & 0 \\
                0 & 0 & 1 & 0 \\
                0 & 0 & 0 & 1
                \end{bmatrix}\]
            </div>
        </div>

        <!-- Demo 1: Matrix Memory Layout Visualizer -->
        <div class="section">
            <h2>4. Demo 1: Matrix Memory Layout Visualizer</h2>
            
            <div class="instruction-box">
                <strong>Interactive Exploration:</strong> This demo shows how the same mathematical matrix 
                is stored differently in memory depending on whether you use column-major (WebGL) or row-major ordering.
            </div>
            
            <div class="demo-container">
                <canvas id="demo1Canvas"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Translation X: <span class="slider-value" id="tx1Value">0.0</span></label>
                        <input type="range" id="tx1" min="-2" max="2" step="0.1" value="0" oninput="updateDemo1()">
                    </div>
                    <div class="control-group">
                        <label>Translation Y: <span class="slider-value" id="ty1Value">0.0</span></label>
                        <input type="range" id="ty1" min="-2" max="2" step="0.1" value="0" oninput="updateDemo1()">
                    </div>
                    <div class="control-group">
                        <label>Rotation (degrees): <span class="slider-value" id="rot1Value">0</span></label>
                        <input type="range" id="rot1" min="-180" max="180" step="5" value="0" oninput="updateDemo1()">
                    </div>
                    <div class="control-group">
                        <label>Scale: <span class="slider-value" id="scale1Value">1.0</span></label>
                        <input type="range" id="scale1" min="0.5" max="2" step="0.1" value="1" oninput="updateDemo1()">
                    </div>
                </div>

                <div class="matrix-display" id="matrixDisplay1">
                    <h3>Current Transformation Matrix</h3>
                    <p><strong>Mathematical Notation (Row-by-Row):</strong></p>
                    <table id="mathMatrix"></table>
                    
                    <p><strong>WebGL Memory Layout (Column-Major):</strong></p>
                    <div id="memoryLayout" style="font-family: monospace; white-space: pre; background: white; padding: 15px; border-radius: 5px;"></div>
                    
                    <p><strong>JavaScript Array Access:</strong></p>
                    <div id="arrayAccess" style="font-family: monospace; font-size: 12px; background: white; padding: 15px; border-radius: 5px;"></div>
                </div>
            </div>
        </div>

        <!-- Demo 2: Transformation Order -->
        <div class="section">
            <h2>5. Demo 2: Transformation Order Matters!</h2>
            
            <div class="warning-box">
                <strong>Non-Commutativity:</strong> Matrix multiplication is NOT commutative! 
                A × B ≠ B × A in general. The order of transformations dramatically affects the final result.
            </div>

            <div class="math-display">
                <p><strong>Common Orders:</strong></p>
                <ul>
                    <li><strong>TRS:</strong> Translate, then Rotate, then Scale → M = T × R × S</li>
                    <li><strong>SRT:</strong> Scale, then Rotate, then Translate → M = S × R × T</li>
                    <li><strong>RTS:</strong> Rotate, then Translate, then Scale → M = R × T × S</li>
                </ul>
                <p>Remember: With column-major matrices and column vectors (WebGL style), 
                we multiply from <strong>right to left</strong>: P' = T × R × S × P</p>
                <p>This means S is applied first, then R, then T!</p>
            </div>
            
            <div class="demo-container">
                <canvas id="demo2Canvas"></canvas>
                
                <div class="order-buttons">
                    <button onclick="setOrder('TRS')" id="btnTRS">TRS</button>
                    <button onclick="setOrder('TSR')" id="btnTSR">TSR</button>
                    <button onclick="setOrder('RTS')" id="btnRTS">RTS</button>
                    <button onclick="setOrder('RST')" id="btnRST">RST</button>
                    <button onclick="setOrder('STR')" id="btnSTR">STR</button>
                    <button onclick="setOrder('SRT')" id="btnSRT">SRT</button>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Translate X: <span class="slider-value" id="tx2Value">1.5</span></label>
                        <input type="range" id="tx2" min="-3" max="3" step="0.1" value="1.5" oninput="updateDemo2()">
                    </div>
                    <div class="control-group">
                        <label>Translate Y: <span class="slider-value" id="ty2Value">0.0</span></label>
                        <input type="range" id="ty2" min="-3" max="3" step="0.1" value="0" oninput="updateDemo2()">
                    </div>
                    <div class="control-group">
                        <label>Rotate (degrees): <span class="slider-value" id="rot2Value">45</span></label>
                        <input type="range" id="rot2" min="-180" max="180" step="5" value="45" oninput="updateDemo2()">
                    </div>
                    <div class="control-group">
                        <label>Scale X: <span class="slider-value" id="sx2Value">1.5</span></label>
                        <input type="range" id="sx2" min="0.3" max="3" step="0.1" value="1.5" oninput="updateDemo2()">
                    </div>
                    <div class="control-group">
                        <label>Scale Y: <span class="slider-value" id="sy2Value">0.7</span></label>
                        <input type="range" id="sy2" min="0.3" max="3" step="0.1" value="0.7" oninput="updateDemo2()">
                    </div>
                </div>

                <div class="matrix-display" id="matrixDisplay2">
                    <h3 id="orderTitle">Current Order: TRS</h3>
                    <p id="orderExplanation"></p>
                    <table id="resultMatrix"></table>
                    <div id="matrixSteps" style="margin-top: 20px;"></div>
                </div>
            </div>

            <div class="info-box">
                <strong>Observe:</strong> Try different orders with the same parameters. Notice how:
                <ul>
                    <li><strong>TRS:</strong> Object scales, rotates around origin, then moves to final position</li>
                    <li><strong>RTS:</strong> Object rotates around origin, moves, then scales (distorts direction)</li>
                    <li><strong>SRT:</strong> Object scales first, rotates, then translates</li>
                </ul>
            </div>
        </div>

        <!-- Demo 3: Interactive 3D Transformation -->
        <div class="section">
            <h2>6. Demo 3: 3D Transformation Explorer</h2>
            
            <div class="instruction-box">
                <strong>Controls:</strong> Manipulate all three transformation types simultaneously and see 
                the resulting matrix in real-time. This demo shows how matrices compose.
            </div>
            
            <div class="demo-container">
                <canvas id="demo3Canvas"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Translate X: <span class="slider-value" id="tx3Value">0.0</span></label>
                        <input type="range" id="tx3" min="-3" max="3" step="0.1" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Translate Y: <span class="slider-value" id="ty3Value">0.0</span></label>
                        <input type="range" id="ty3" min="-3" max="3" step="0.1" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Translate Z: <span class="slider-value" id="tz3Value">0.0</span></label>
                        <input type="range" id="tz3" min="-3" max="3" step="0.1" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Rotate X: <span class="slider-value" id="rx3Value">0</span></label>
                        <input type="range" id="rx3" min="-180" max="180" step="5" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Rotate Y: <span class="slider-value" id="ry3Value">0</span></label>
                        <input type="range" id="ry3" min="-180" max="180" step="5" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Rotate Z: <span class="slider-value" id="rz3Value">0</span></label>
                        <input type="range" id="rz3" min="-180" max="180" step="5" value="0" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Scale X: <span class="slider-value" id="sx3Value">1.0</span></label>
                        <input type="range" id="sx3" min="0.3" max="3" step="0.1" value="1" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Scale Y: <span class="slider-value" id="sy3Value">1.0</span></label>
                        <input type="range" id="sy3" min="0.3" max="3" step="0.1" value="1" oninput="updateDemo3()">
                    </div>
                    <div class="control-group">
                        <label>Scale Z: <span class="slider-value" id="sz3Value">1.0</span></label>
                        <input type="range" id="sz3" min="0.3" max="3" step="0.1" value="1" oninput="updateDemo3()">
                    </div>
                </div>

                <div class="controls">
                    <button onclick="resetDemo3()">Reset All</button>
                    <button onclick="toggleAxes3()">Toggle Axes</button>
                    <button onclick="toggleWireframe3()">Toggle Wireframe</button>
                </div>

                <div class="matrix-display" id="matrixDisplay3">
                    <h3>Complete Transformation Matrix (TRS Order)</h3>
                    <table id="fullMatrix"></table>
                    
                    <div style="margin-top: 20px;">
                        <strong>Matrix Decomposition:</strong>
                        <div id="decomposition"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Summary -->
        <div class="section">
            <h2>7. Key Takeaways</h2>
            
            <table>
                <tr>
                    <th>Concept</th>
                    <th>Key Points</th>
                </tr>
                <tr>
                    <td><strong>Column-Major</strong></td>
                    <td>WebGL stores matrices column-by-column. First 4 elements = first column!</td>
                </tr>
                <tr>
                    <td><strong>Matrix Multiplication</strong></td>
                    <td>P' = M × P (matrix on left). Compose right-to-left: M = T × R × S means S first!</td>
                </tr>
                <tr>
                    <td><strong>Order Matters</strong></td>
                    <td>TRS ≠ RTS ≠ SRT. Always be explicit about transformation order</td>
                </tr>
                <tr>
                    <td><strong>Homogeneous Coords</strong></td>
                    <td>Points: (x,y,z,1), Vectors: (x,y,z,0). Enables translation as matrix multiply</td>
                </tr>
                <tr>
                    <td><strong>gl.uniformMatrix4fv</strong></td>
                    <td>Second parameter is "transpose". Use <code>false</code> for column-major data</td>
                </tr>
            </table>

            <div class="code-box">
// Best practices for WebGL transformations

// 1. Create matrices in column-major order
const translation = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    tx, ty, tz, 1
];

// 2. Multiply in correct order (right to left for column vectors)
// If you want: Scale, then Rotate, then Translate
// Write: M = T * R * S
const model = multiplyMatrices(T, multiplyMatrices(R, S));

// 3. Send to WebGL without transpose
gl.uniformMatrix4fv(uModelLocation, false, model);

// 4. In shader, multiply matrix on LEFT of vector
// gl_Position = uModel * vec4(aPosition, 1.0);
            </div>
        </div>

        <!-- WebGL Code Reference -->
        <div class="section">
            <h2>8. Complete WebGL Code Reference</h2>
            
            <h3>Vertex Shader</h3>
            <div class="code-box">
attribute vec3 aPosition;
uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProjection;

void main() {
    // Apply transformations: Projection × View × Model × Position
    // Remember: matrix multiplication is RIGHT to LEFT
    // So Model is applied first, then View, then Projection
    gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
}
            </div>

            <h3>JavaScript Matrix Operations</h3>
            <div class="code-box">
// Matrix multiplication (column-major, 4x4)
function multiplyMatrices(a, b) {
    const result = new Array(16);
    for (let col = 0; col < 4; col++) {
        for (let row = 0; row < 4; row++) {
            result[col * 4 + row] = 
                a[0 * 4 + row] * b[col * 4 + 0] +
                a[1 * 4 + row] * b[col * 4 + 1] +
                a[2 * 4 + row] * b[col * 4 + 2] +
                a[3 * 4 + row] * b[col * 4 + 3];
        }
    }
    return result;
}

// Create translation matrix
function translation(tx, ty, tz) {
    return [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        tx, ty, tz, 1
    ];
}

// Create scaling matrix
function scaling(sx, sy, sz) {
    return [
        sx, 0, 0, 0,
        0, sy, 0, 0,
        0, 0, sz, 0,
        0, 0, 0, 1
    ];
}

// Create rotation around Z axis
function rotationZ(angleInRadians) {
    const c = Math.cos(angleInRadians);
    const s = Math.sin(angleInRadians);
    return [
        c, s, 0, 0,
        -s, c, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    ];
}
            </div>
        </div>
    </div>

    <script>
        // Matrix utility functions (column-major)
        function identity() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        function multiply(a, b) {
            const result = new Array(16);
            for (let col = 0; col < 4; col++) {
                for (let row = 0; row < 4; row++) {
                    result[col * 4 + row] = 
                        a[0 * 4 + row] * b[col * 4 + 0] +
                        a[1 * 4 + row] * b[col * 4 + 1] +
                        a[2 * 4 + row] * b[col * 4 + 2] +
                        a[3 * 4 + row] * b[col * 4 + 3];
                }
            }
            return result;
        }

        function translation(tx, ty, tz) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                tx, ty, tz, 1
            ];
        }

        function scaling(sx, sy, sz) {
            return [
                sx, 0, 0, 0,
                0, sy, 0, 0,
                0, 0, sz, 0,
                0, 0, 0, 1
            ];
        }

        function rotationX(rad) {
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            return [
                1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1
            ];
        }

        function rotationY(rad) {
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            return [
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ];
        }

        function rotationZ(rad) {
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            return [
                c, s, 0, 0,
                -s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        function perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ];
        }

        function lookAt(eye, center, up) {
            const zAxis = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);
            
            return [
                xAxis[0], yAxis[0], zAxis[0], 0,
                xAxis[1], yAxis[1], zAxis[1], 0,
                xAxis[2], yAxis[2], zAxis[2], 0,
                -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
            ];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
        }

        function formatMatrix(m) {
            let html = '<table><tbody>';
            for (let row = 0; row < 4; row++) {
                html += '<tr>';
                for (let col = 0; col < 4; col++) {
                    const val = m[col * 4 + row];
                    html += `<td>${val.toFixed(3)}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table>';
            return html;
        }

        // WebGL initialization
        function initGL(canvas) {
            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported');
                return null;
            }
            return gl;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Shaders
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uMVP;
            varying vec3 vColor;
            void main() {
                gl_Position = uMVP * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // Create a cube
        function createCube() {
            const positions = [
                // Front
                -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                // Back
                -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,
                // Top
                -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,
                // Bottom
                -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
                // Right
                 0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,
                // Left
                -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5
            ];

            const colors = [
                1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,
                0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0,
                0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,
                1, 1, 0,  1, 1, 0,  1, 1, 0,  1, 1, 0,
                1, 0, 1,  1, 0, 1,  1, 0, 1,  1, 0, 1,
                0, 1, 1,  0, 1, 1,  0, 1, 1,  0, 1, 1
            ];

            const indices = [
                0,  1,  2,   0,  2,  3,
                4,  5,  6,   4,  6,  7,
                8,  9, 10,   8, 10, 11,
                12, 13, 14,  12, 14, 15,
                16, 17, 18,  16, 18, 19,
                20, 21, 22,  20, 22, 23
            ];

            return { positions, colors, indices };
        }

        // Demo 1: Matrix Layout Visualizer
        let demo1 = {
            canvas: null,
            gl: null,
            program: null,
            positionBuffer: null,
            colorBuffer: null,
            indexBuffer: null
        };

        function initDemo1() {
            demo1.canvas = document.getElementById('demo1Canvas');
            demo1.gl = initGL(demo1.canvas);
            if (!demo1.gl) return;

            const gl = demo1.gl;
            demo1.canvas.width = 800;
            demo1.canvas.height = 600;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            demo1.program = createProgram(gl, vertexShader, fragmentShader);

            const cube = createCube();
            
            demo1.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo1.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.positions), gl.STATIC_DRAW);

            demo1.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo1.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.colors), gl.STATIC_DRAW);

            demo1.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo1.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube.indices), gl.STATIC_DRAW);

            updateDemo1();
        }

        function updateDemo1() {
            const tx = parseFloat(document.getElementById('tx1').value);
            const ty = parseFloat(document.getElementById('ty1').value);
            const rot = parseFloat(document.getElementById('rot1').value) * Math.PI / 180;
            const scale = parseFloat(document.getElementById('scale1').value);

            document.getElementById('tx1Value').textContent = tx.toFixed(1);
            document.getElementById('ty1Value').textContent = ty.toFixed(1);
            document.getElementById('rot1Value').textContent = (rot * 180 / Math.PI).toFixed(0);
            document.getElementById('scale1Value').textContent = scale.toFixed(1);

            const T = translation(tx, ty, 0);
            const R = rotationZ(rot);
            const S = scaling(scale, scale, scale);
            const model = multiply(T, multiply(R, S));

            // Display mathematical notation
            document.getElementById('mathMatrix').innerHTML = formatMatrix(model);

            // Display memory layout
            let memLayout = 'Float32Array([\n';
            for (let i = 0; i < 16; i++) {
                if (i % 4 === 0 && i > 0) memLayout += '\n';
                memLayout += '  ' + model[i].toFixed(3);
                if (i < 15) memLayout += ',';
            }
            memLayout += '\n])';
            document.getElementById('memoryLayout').textContent = memLayout;

            // Display array access
            let access = 'Array indices (column-major):\n\n';
            access += 'Column 0: m[0]=' + model[0].toFixed(2) + ', m[1]=' + model[1].toFixed(2) + 
                      ', m[2]=' + model[2].toFixed(2) + ', m[3]=' + model[3].toFixed(2) + '\n';
            access += 'Column 1: m[4]=' + model[4].toFixed(2) + ', m[5]=' + model[5].toFixed(2) + 
                      ', m[6]=' + model[6].toFixed(2) + ', m[7]=' + model[7].toFixed(2) + '\n';
            access += 'Column 2: m[8]=' + model[8].toFixed(2) + ', m[9]=' + model[9].toFixed(2) + 
                      ', m[10]=' + model[10].toFixed(2) + ', m[11]=' + model[11].toFixed(2) + '\n';
            access += 'Column 3: m[12]=' + model[12].toFixed(2) + ', m[13]=' + model[13].toFixed(2) + 
                      ', m[14]=' + model[14].toFixed(2) + ', m[15]=' + model[15].toFixed(2);
            document.getElementById('arrayAccess').textContent = access;

            renderDemo1(model);
        }

        function renderDemo1(model) {
            const gl = demo1.gl;
            gl.viewport(0, 0, demo1.canvas.width, demo1.canvas.height);
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(demo1.program);

            const view = lookAt([0, 0, 5], [0, 0, 0], [0, 1, 0]);
            const projection = perspective(45 * Math.PI / 180, demo1.canvas.width / demo1.canvas.height, 0.1, 100);
            const mvp = multiply(projection, multiply(view, model));

            const aPosition = gl.getAttribLocation(demo1.program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo1.positionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const aColor = gl.getAttribLocation(demo1.program, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo1.colorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo1.indexBuffer);

            const uMVP = gl.getUniformLocation(demo1.program, 'uMVP');
            gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));

            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }

        // Demo 2: Transformation Order
        let demo2 = {
            canvas: null,
            gl: null,
            program: null,
            positionBuffer: null,
            colorBuffer: null,
            indexBuffer: null,
            currentOrder: 'TRS'
        };

        function initDemo2() {
            demo2.canvas = document.getElementById('demo2Canvas');
            demo2.gl = initGL(demo2.canvas);
            if (!demo2.gl) return;

            const gl = demo2.gl;
            demo2.canvas.width = 800;
            demo2.canvas.height = 600;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            demo2.program = createProgram(gl, vertexShader, fragmentShader);

            const cube = createCube();
            
            demo2.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo2.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.positions), gl.STATIC_DRAW);

            demo2.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo2.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.colors), gl.STATIC_DRAW);

            demo2.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo2.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube.indices), gl.STATIC_DRAW);

            setOrder('TRS');
        }

        function setOrder(order) {
            demo2.currentOrder = order;
            
            // Update button states
            document.querySelectorAll('.order-buttons button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn' + order).classList.add('active');

            updateDemo2();
        }

        function updateDemo2() {
            const tx = parseFloat(document.getElementById('tx2').value);
            const ty = parseFloat(document.getElementById('ty2').value);
            const rot = parseFloat(document.getElementById('rot2').value) * Math.PI / 180;
            const sx = parseFloat(document.getElementById('sx2').value);
            const sy = parseFloat(document.getElementById('sy2').value);

            document.getElementById('tx2Value').textContent = tx.toFixed(1);
            document.getElementById('ty2Value').textContent = ty.toFixed(1);
            document.getElementById('rot2Value').textContent = (rot * 180 / Math.PI).toFixed(0);
            document.getElementById('sx2Value').textContent = sx.toFixed(1);
            document.getElementById('sy2Value').textContent = sy.toFixed(1);

            const T = translation(tx, ty, 0);
            const R = rotationZ(rot);
            const S = scaling(sx, sy, 1);

            let model, explanation, steps = '';
            
            switch(demo2.currentOrder) {
                case 'TRS':
                    model = multiply(T, multiply(R, S));
                    explanation = 'T × R × S: Scale first (S), then Rotate (R), then Translate (T)';
                    steps = '<p><strong>Step 1:</strong> Scale the object</p>';
                    steps += '<p><strong>Step 2:</strong> Rotate around origin</p>';
                    steps += '<p><strong>Step 3:</strong> Translate to final position</p>';
                    break;
                case 'TSR':
                    model = multiply(T, multiply(S, R));
                    explanation = 'T × S × R: Rotate first (R), then Scale (S), then Translate (T)';
                    steps = '<p><strong>Step 1:</strong> Rotate around origin</p>';
                    steps += '<p><strong>Step 2:</strong> Scale (may distort rotated shape)</p>';
                    steps += '<p><strong>Step 3:</strong> Translate to final position</p>';
                    break;
                case 'RTS':
                    model = multiply(R, multiply(T, S));
                    explanation = 'R × T × S: Scale first (S), then Translate (T), then Rotate (R)';
                    steps = '<p><strong>Step 1:</strong> Scale the object</p>';
                    steps += '<p><strong>Step 2:</strong> Translate</p>';
                    steps += '<p><strong>Step 3:</strong> Rotate (spins around origin, moves translated position)</p>';
                    break;
                case 'RST':
                    model = multiply(R, multiply(S, T));
                    explanation = 'R × S × T: Translate first (T), then Scale (S), then Rotate (R)';
                    steps = '<p><strong>Step 1:</strong> Translate</p>';
                    steps += '<p><strong>Step 2:</strong> Scale (affects translation!)</p>';
                    steps += '<p><strong>Step 3:</strong> Rotate around origin</p>';
                    break;
                case 'STR':
                    model = multiply(S, multiply(T, R));
                    explanation = 'S × T × R: Rotate first (R), then Translate (T), then Scale (S)';
                    steps = '<p><strong>Step 1:</strong> Rotate around origin</p>';
                    steps += '<p><strong>Step 2:</strong> Translate</p>';
                    steps += '<p><strong>Step 3:</strong> Scale (affects final position)</p>';
                    break;
                case 'SRT':
                    model = multiply(S, multiply(R, T));
                    explanation = 'S × R × T: Translate first (T), then Rotate (R), then Scale (S)';
                    steps = '<p><strong>Step 1:</strong> Translate</p>';
                    steps += '<p><strong>Step 2:</strong> Rotate (spins translation vector)</p>';
                    steps += '<p><strong>Step 3:</strong> Scale everything</p>';
                    break;
            }

            document.getElementById('orderTitle').textContent = 'Current Order: ' + demo2.currentOrder;
            document.getElementById('orderExplanation').textContent = explanation;
            document.getElementById('resultMatrix').innerHTML = formatMatrix(model);
            document.getElementById('matrixSteps').innerHTML = steps;

            renderDemo2(model);
        }

        function renderDemo2(model) {
            const gl = demo2.gl;
            gl.viewport(0, 0, demo2.canvas.width, demo2.canvas.height);
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(demo2.program);

            const view = lookAt([0, 2, 6], [0, 0, 0], [0, 1, 0]);
            const projection = perspective(45 * Math.PI / 180, demo2.canvas.width / demo2.canvas.height, 0.1, 100);
            const mvp = multiply(projection, multiply(view, model));

            const aPosition = gl.getAttribLocation(demo2.program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo2.positionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const aColor = gl.getAttribLocation(demo2.program, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo2.colorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo2.indexBuffer);

            const uMVP = gl.getUniformLocation(demo2.program, 'uMVP');
            gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));

            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
            // Draw reference cube at origin
            const originModel = identity();
            const originMVP = multiply(projection, multiply(view, originModel));
            gl.uniformMatrix4fv(uMVP, false, new Float32Array(originMVP));
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.drawElements(gl.LINES, 36, gl.UNSIGNED_SHORT, 0);
            gl.disable(gl.BLEND);
        }

        // Demo 3: 3D Transformation Explorer
        let demo3 = {
            canvas: null,
            gl: null,
            program: null,
            positionBuffer: null,
            colorBuffer: null,
            indexBuffer: null,
            showAxes: true,
            wireframe: false
        };

        function initDemo3() {
            demo3.canvas = document.getElementById('demo3Canvas');
            demo3.gl = initGL(demo3.canvas);
            if (!demo3.gl) return;

            const gl = demo3.gl;
            demo3.canvas.width = 800;
            demo3.canvas.height = 600;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            demo3.program = createProgram(gl, vertexShader, fragmentShader);

            const cube = createCube();
            
            demo3.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo3.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.positions), gl.STATIC_DRAW);

            demo3.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, demo3.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.colors), gl.STATIC_DRAW);

            demo3.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo3.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube.indices), gl.STATIC_DRAW);

            updateDemo3();
        }

        function updateDemo3() {
            const tx = parseFloat(document.getElementById('tx3').value);
            const ty = parseFloat(document.getElementById('ty3').value);
            const tz = parseFloat(document.getElementById('tz3').value);
            const rx = parseFloat(document.getElementById('rx3').value) * Math.PI / 180;
            const ry = parseFloat(document.getElementById('ry3').value) * Math.PI / 180;
            const rz = parseFloat(document.getElementById('rz3').value) * Math.PI / 180;
            const sx = parseFloat(document.getElementById('sx3').value);
            const sy = parseFloat(document.getElementById('sy3').value);
            const sz = parseFloat(document.getElementById('sz3').value);

            document.getElementById('tx3Value').textContent = tx.toFixed(1);
            document.getElementById('ty3Value').textContent = ty.toFixed(1);
            document.getElementById('tz3Value').textContent = tz.toFixed(1);
            document.getElementById('rx3Value').textContent = (rx * 180 / Math.PI).toFixed(0);
            document.getElementById('ry3Value').textContent = (ry * 180 / Math.PI).toFixed(0);
            document.getElementById('rz3Value').textContent = (rz * 180 / Math.PI).toFixed(0);
            document.getElementById('sx3Value').textContent = sx.toFixed(1);
            document.getElementById('sy3Value').textContent = sy.toFixed(1);
            document.getElementById('sz3Value').textContent = sz.toFixed(1);

            const T = translation(tx, ty, tz);
            const Rx = rotationX(rx);
            const Ry = rotationY(ry);
            const Rz = rotationZ(rz);
            const S = scaling(sx, sy, sz);

            const R = multiply(Rz, multiply(Ry, Rx));
            const model = multiply(T, multiply(R, S));

            document.getElementById('fullMatrix').innerHTML = formatMatrix(model);
            
            let decomp = '<div style="font-family: monospace; font-size: 14px;">';
            decomp += '<p><strong>Translation:</strong> (' + tx.toFixed(2) + ', ' + ty.toFixed(2) + ', ' + tz.toFixed(2) + ')</p>';
            decomp += '<p><strong>Rotation:</strong> X=' + (rx*180/Math.PI).toFixed(1) + '°, Y=' + (ry*180/Math.PI).toFixed(1) + '°, Z=' + (rz*180/Math.PI).toFixed(1) + '°</p>';
            decomp += '<p><strong>Scale:</strong> (' + sx.toFixed(2) + ', ' + sy.toFixed(2) + ', ' + sz.toFixed(2) + ')</p>';
            decomp += '</div>';
            document.getElementById('decomposition').innerHTML = decomp;

            renderDemo3(model);
        }

        function renderDemo3(model) {
            const gl = demo3.gl;
            gl.viewport(0, 0, demo3.canvas.width, demo3.canvas.height);
            gl.clearColor(0.95, 0.95, 0.95, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(demo3.program);

            const view = lookAt([3, 3, 5], [0, 0, 0], [0, 1, 0]);
            const projection = perspective(45 * Math.PI / 180, demo3.canvas.width / demo3.canvas.height, 0.1, 100);
            const mvp = multiply(projection, multiply(view, model));

            const aPosition = gl.getAttribLocation(demo3.program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo3.positionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const aColor = gl.getAttribLocation(demo3.program, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, demo3.colorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, demo3.indexBuffer);

            const uMVP = gl.getUniformLocation(demo3.program, 'uMVP');
            gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));

            if (demo3.wireframe) {
                gl.drawElements(gl.LINES, 36, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            }

            // Draw axes if enabled
            if (demo3.showAxes) {
                drawAxes3D(gl, demo3.program, view, projection);
            }
        }

        function drawAxes3D(gl, program, view, projection) {
            const axesPositions = [
                0, 0, 0,  2, 0, 0,  // X axis
                0, 0, 0,  0, 2, 0,  // Y axis
                0, 0, 0,  0, 0, 2   // Z axis
            ];
            
            const axesColors = [
                1, 0, 0,  1, 0, 0,  // Red for X
                0, 1, 0,  0, 1, 0,  // Green for Y
                0, 0, 1,  0, 0, 1   // Blue for Z
            ];

            const axesPosBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, axesPosBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(axesPositions), gl.STATIC_DRAW);

            const axesColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, axesColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(axesColors), gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, axesPosBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const aColor = gl.getAttribLocation(program, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, axesColorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            const modelMatrix = identity();
            const mvp = multiply(projection, multiply(view, modelMatrix));
            const uMVP = gl.getUniformLocation(program, 'uMVP');
            gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));

            gl.lineWidth(3);
            gl.drawArrays(gl.LINES, 0, 6);
        }

        function resetDemo3() {
            document.getElementById('tx3').value = 0;
            document.getElementById('ty3').value = 0;
            document.getElementById('tz3').value = 0;
            document.getElementById('rx3').value = 0;
            document.getElementById('ry3').value = 0;
            document.getElementById('rz3').value = 0;
            document.getElementById('sx3').value = 1;
            document.getElementById('sy3').value = 1;
            document.getElementById('sz3').value = 1;
            updateDemo3();
        }

        function toggleAxes3() {
            demo3.showAxes = !demo3.showAxes;
            updateDemo3();
        }

        function toggleWireframe3() {
            demo3.wireframe = !demo3.wireframe;
            updateDemo3();
        }

        // Initialize all demos when page loads
        window.addEventListener('load', () => {
            initDemo1();
            initDemo2();
            initDemo3();
        });
    </script>
</body>
</html>